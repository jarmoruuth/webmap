<!DOCTYPE html>
<html>
<head>
  <title>Clickable Ski Lifts (Endpoints, Stations, Retry, Permalink, Ele filter)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body { font-family: system-ui, sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #f7f7f7; position: sticky; top: 0; z-index: 1000; }
    #controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    #map { height: calc(100vh - 88px); width: 100%; }
    input[type="number"] { width: 110px; padding: 6px 8px; }
    small { color: #555; }
    .legend { display:flex; gap:10px; align-items:center; }
    .key { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .pill { background:#fff; border:1px solid #ddd; border-radius:999px; padding:3px 10px; display:inline-flex; align-items:center; gap:6px; }
    button { padding:6px 10px; border:1px solid #ddd; background:#fff; border-radius:8px; cursor:pointer; }
    button:active { transform: translateY(1px); }

    /* Loading overlay */
    #loading {
      position: fixed; inset: 0;
      background: rgba(255,255,255,0.7);
      display: none; align-items: center; justify-content: center;
      z-index: 2000;
    }
    #loading .box {
      display:flex; flex-direction: column; align-items:center; gap:10px;
      background:#fff; border:1px solid #ddd; border-radius:12px; padding:16px 20px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
    }
    .spinner {
      width: 28px; height: 28px;
      border: 3px solid #ddd;
      border-top-color: #888;
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <header>
    <div id="controls">
      <div><strong>Click the map</strong> to find ski lifts nearby.</div>

      <label>
        Radius (km):
        <input id="radiusKm" type="number" min="0.1" step="0.1" value="10">
      </label>
      <small id="radiusNote">Searching within 10.0 km</small>

      <label class="pill" title="Filter by top elevation derived from ele tags on the lift or its endpoints">
        Min top elevation (m):
        <input id="minEle" type="number" min="0" step="50" value="0">
      </label>
      <small id="eleNote">No elevation filter</small>

      <label class="pill" title="Also show OSM nodes tagged aerialway=station (honors elevation filter)">
        <input id="toggleStations" type="checkbox">
        Include station nodes
      </label>

      <!-- DEM: new toggle -->
      <label class="pill" title="When a lift has no ele tags, estimate top elevation from terrain at its endpoints">
        <input id="toggleDemFallback" type="checkbox" checked>
        Use DEM fallback for top ele
      </label>

      <button id="shareBtn" title="Copy a link to this view & settings">Share link</button>

      <div class="legend">
        <span class="key"><span class="dot" style="background:#d62728"></span>Gondola / Cable car</span>
        <span class="key"><span class="dot" style="background:#1f77b4"></span>Chair / Drag / Tow</span>
        <span class="key"><span class="dot" style="background:#9467bd"></span>Other aerialway</span>
        <span class="key"><span class="dot" style="background:#ff7f0e"></span>Station node</span>
      </div>
    </div>
  </header>

  <div id="map"></div>

  <!-- Loading overlay -->
  <div id="loading" aria-live="polite">
    <div class="box">
      <div class="spinner" aria-hidden="true"></div>
      <div>Loading…</div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // --- Config
    // Default center: Zermatt, Switzerland
    const initialLat = 46.0207;
    const initialLon = 7.7491;
    const initialZoom = 12;

    const MIN_RADIUS_M = 100;    // 100 m guard
    const MAX_RADIUS_M = 100000; // 100 km guard

    // Overpass endpoints (primary -> fallbacks)
    const OVERPASS_ENDPOINTS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.fr/api/interpreter'
    ];
    const OVERPASS_TIMEOUT_MS = 25000;

    // DEM: Elevation providers (no key)
    const OPENELEVATION_URL = 'https://api.open-elevation.com/api/v1/lookup';
    const OPENTOPODATA_URL  = 'https://api.opentopodata.org/v1/srtm90m';
    const DEM_BATCH_SIZE = 80;

    // --- Helpers
    const radiusInput   = document.getElementById('radiusKm');
    const radiusNote    = document.getElementById('radiusNote');
    const minEleInput   = document.getElementById('minEle');
    const eleNote       = document.getElementById('eleNote');
    const stationsInput = document.getElementById('toggleStations');
    const demFallback   = document.getElementById('toggleDemFallback');
    const shareBtn      = document.getElementById('shareBtn');
    const loadingEl     = document.getElementById('loading');

    function showLoading(on) { loadingEl.style.display = on ? 'flex' : 'none'; }

    function kmToMeters(km) {
      const m = Number(km) * 1000;
      if (Number.isNaN(m)) return 10000;
      return Math.min(Math.max(m, MIN_RADIUS_M), MAX_RADIUS_M);
    }
    function getRadiusMeters() { return kmToMeters(radiusInput.value); }
    function updateRadiusNote() {
      const km = Math.round((getRadiusMeters() / 1000) * 10) / 10;
      radiusNote.textContent = `Searching within ${km.toFixed(1)} km`;
    }

    function getMinEleMeters() {
      const v = Number(minEleInput.value);
      return Number.isFinite(v) ? Math.max(0, v) : 0;
    }
    function updateEleNote() {
      const m = getMinEleMeters();
      eleNote.textContent = m > 0 ? `Showing features with top ele ≥ ${m} m` : 'No elevation filter';
    }

    // Robust ele parser (handles "3160", "3160 m", "3,160", etc.)
    function parseEle(ele) {
      if (ele == null) return null;
      const s = String(ele).trim().replace(',', '.');
      const m = s.match(/-?\d+(?:\.\d+)?/);
      return m ? parseFloat(m[0]) : null;
    }

    // DEM: tiny cache so we don't look up the same point twice
    const demCache = new Map(); // key "lat,lon" rounded
    const roundKey = (lat, lon) => `${lat.toFixed(5)},${lon.toFixed(5)}`;

    async function fetchDEM(points) {
      // points: [{lat, lon}]
      const unknown = [];
      for (const p of points) {
        const k = roundKey(p.lat, p.lon);
        if (!demCache.has(k)) unknown.push(p);
      }
      if (!unknown.length) return;

      // helper: Open-Elevation POST
      async function queryOpenElevation(batch) {
        const body = { locations: batch.map(p => ({ latitude: p.lat, longitude: p.lon })) };
        const res = await fetch(OPENELEVATION_URL, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
        });
        if (!res.ok) throw new Error('Open-Elevation HTTP ' + res.status);
        const json = await res.json();
        (json.results || []).forEach((r, i) => {
          const k = roundKey(batch[i].lat, batch[i].lon);
          if (typeof r.elevation === 'number') demCache.set(k, r.elevation);
        });
      }

      // helper: OpenTopoData GET fallback
      async function queryOpenTopoData(batch) {
        const locStr = batch.map(p => `${p.lat},${p.lon}`).join('|');
        const res = await fetch(`${OPENTOPODATA_URL}?locations=${encodeURIComponent(locStr)}`);
        if (!res.ok) throw new Error('OpenTopoData HTTP ' + res.status);
        const json = await res.json();
        (json.results || []).forEach((r, i) => {
          const k = roundKey(batch[i].lat, batch[i].lon);
          if (typeof r.elevation === 'number') demCache.set(k, r.elevation);
        });
      }

      for (let i = 0; i < unknown.length; i += DEM_BATCH_SIZE) {
        const batch = unknown.slice(i, i + DEM_BATCH_SIZE);
        try {
          await queryOpenElevation(batch);
        } catch (e1) {
          try { await queryOpenTopoData(batch); }
          catch (e2) { /* ignore; we'll just miss DEM for this batch */ }
        }
      }
    }

    // --- Map init
    const map = L.map('map').setView([initialLat, initialLon], initialZoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let circleLayer = null;
    const lineLayer   = L.layerGroup().addTo(map); // polylines
    const markerLayer = L.layerGroup().addTo(map); // endpoints + stations (no clustering)
    let lastClickLatLng = null;

    // --- Colors by lift kind
    function liftColor(tags){
      const t = (tags.aerialway || '').toLowerCase();
      if (t === 'gondola' || t === 'cable_car' || t === 'mixed_lift') return '#d62728';
      if (t.includes('chair') || t.includes('drag') || t.includes('t-bar') || t.includes('j-bar') ||
          t === 'platter' || t === 'rope_tow' || t === 'magic_carpet') return '#1f77b4';
      return '#9467bd';
    }

    // --- Overpass fetch with retry & timeout
    async function fetchOverpass(query) {
      let lastErr = null;
      for (const url of OVERPASS_ENDPOINTS) {
        try {
          const ctrl = new AbortController();
          const t = setTimeout(() => ctrl.abort(), OVERPASS_TIMEOUT_MS);
          const res = await fetch(url, { method: 'POST', body: query, signal: ctrl.signal });
          clearTimeout(t);
          if (!res.ok) { lastErr = new Error(url + ' HTTP ' + res.status); continue; }
          return await res.json();
        } catch (e) {
          lastErr = e;
          await new Promise(r => setTimeout(r, 300)); // brief backoff
        }
      }
      throw lastErr || new Error('All Overpass endpoints failed');
    }

    // --- URL state (permalink)
    function readStateFromURL() {
      const h = new URLSearchParams(location.hash.replace(/^#/, ''));
      const lat = parseFloat(h.get('lat'));
      const lon = parseFloat(h.get('lon'));
      const z   = parseFloat(h.get('z'));
      const rkm = parseFloat(h.get('rkm'));
      const st  = h.get('st') === '1';
      const q   = h.get('q') === '1';
      const em  = parseFloat(h.get('emin'));
      const dem = h.get('dem') === '1';
      const state = {};
      if (!Number.isNaN(lat) && !Number.isNaN(lon)) state.center = [lat, lon];
      if (!Number.isNaN(z))   state.zoom = z;
      if (!Number.isNaN(rkm)) state.radiusKm = rkm;
      if (!Number.isNaN(em))  state.minEle = em;
      state.stations = st;
      state.autoQuery = q;
      state.dem = dem;
      return state;
    }
    function writeStateToURL() {
      const c = map.getCenter();
      const z = map.getZoom();
      const params = new URLSearchParams(location.hash.replace(/^#/, ''));
      params.set('lat', c.lat.toFixed(6));
      params.set('lon', c.lng.toFixed(6));
      params.set('z', String(z));
      params.set('rkm', (getRadiusMeters()/1000).toFixed(2));
      params.set('emin', String(getMinEleMeters()));
      params.set('st', stationsInput.checked ? '1' : '0');
      params.set('dem', demFallback.checked ? '1' : '0');
      params.set('q', '1'); // ensure opening the link will auto-run a query
      const newHash = '#' + params.toString();
      if (location.hash !== newHash) history.replaceState(null, '', newHash);
    }

    // Copy permalink to clipboard
    shareBtn.addEventListener('click', async () => {
      writeStateToURL();
      try {
        await navigator.clipboard.writeText(location.href);
        shareBtn.textContent = 'Link copied!';
        setTimeout(() => shareBtn.textContent = 'Share link', 1200);
      } catch {
        prompt('Copy this link:', location.href);
      }
    });

    // Update permalink on view/controls change
    map.on('moveend', writeStateToURL);

    // --- Query & render (lifts + optional station nodes, elevation filter incl. DEM fallback)
    async function findLiftsNear(lat, lon, radiusMeters) {
      // Draw/refresh the search circle
      if (circleLayer) map.removeLayer(circleLayer);
      circleLayer = L.circle([lat, lon], {
        radius: radiusMeters, color: 'blue', fillOpacity: 0.08
      }).addTo(map);

      const stationsQL = stationsInput.checked
        ? `node["aerialway"="station"](around:${radiusMeters},${lat},${lon});`
        : ``;

      const query = `
        [out:json][timeout:25];
        (
          way["aerialway"]["aerialway"!~"^(pylon|station)$"](around:${radiusMeters},${lat},${lon});
          ${stationsQL}
        );
        out body geom;
        >;
        out body;
      `;

      showLoading(true);
      try {
        const data = await fetchOverpass(query);

        // reset layers
        lineLayer.clearLayers();
        markerLayer.clearLayers();

        if (!data.elements || data.elements.length === 0) return;

        // Build maps
        const nodesById = new Map();
        const ways = [];
        for (const el of data.elements) {
          if (el.type === 'node') nodesById.set(el.id, el);
          else if (el.type === 'way') ways.push(el);
        }

        function htmlTags(tags) {
          const entries = Object.entries(tags || {}).sort(([a],[b]) => a.localeCompare(b));
          if (!entries.length) return '<i>No additional details</i>';
          return entries.map(([k,v]) => `<b>${k}</b>: ${String(v)}`).join('<br>');
        }

        const minEle = getMinEleMeters();

        // 1) Pre-scan lifts, compute tag-based topEle and collect DEM points when needed
        const liftInfo = [];
        const demPoints = []; // {lat, lon}
        for (const w of ways) {
          const tags = w.tags || {};
          const coords = (w.geometry || []).map(p => [p.lat, p.lon]);
          if (coords.length < 2) continue;

          let ndStart = null, ndEnd = null;
          if (Array.isArray(w.nodes) && w.nodes.length >= 2) {
            ndStart = nodesById.get(w.nodes[0]) || null;
            ndEnd   = nodesById.get(w.nodes[w.nodes.length - 1]) || null;
          }

          const cands = [];
          const wayEle    = parseEle(tags.ele);
          const wayEleTo  = parseEle(tags['ele:to']);
          const wayEleFrom= parseEle(tags['ele:from']);
          if (wayEle    != null) cands.push(wayEle);
          if (wayEleTo  != null) cands.push(wayEleTo);
          if (wayEleFrom!= null) cands.push(wayEleFrom);

          const ndStartEle = parseEle(ndStart?.tags?.ele);
          const ndEndEle   = parseEle(ndEnd?.tags?.ele);
          if (ndStartEle != null) cands.push(ndStartEle);
          if (ndEndEle   != null) cands.push(ndEndEle);

          const topEleTagged = cands.length ? Math.max(...cands) : null;

          // Collect DEM endpoints if needed and available
          let startLatLon = null, endLatLon = null;
          if (demFallback.checked && topEleTagged == null) {
            if (ndStart) startLatLon = { lat: ndStart.lat, lon: ndStart.lon };
            else startLatLon = { lat: coords[0][0], lon: coords[0][1] };
            if (ndEnd)   endLatLon   = { lat: ndEnd.lat, lon: ndEnd.lon };
            else endLatLon   = { lat: coords[coords.length-1][0], lon: coords[coords.length-1][1] };
            demPoints.push(startLatLon, endLatLon);
          }

          liftInfo.push({
            w, tags, coords, ndStart, ndEnd,
            topEleTagged,
            startLatLon, endLatLon,
            topEleFinal: null,  // filled later
            source: null        // 'tags' | 'dem' | null
          });
        }

        // 2) If requested, fetch DEM for all missing points (batched + cached)
        if (demFallback.checked && demPoints.length) {
          await fetchDEM(demPoints);
        }

        // 3) Decide final top elevation per lift (tags first, else DEM)
        for (const Lf of liftInfo) {
          if (Lf.topEleTagged != null) {
            Lf.topEleFinal = Lf.topEleTagged;
            Lf.source = 'tags';
          } else if (Lf.startLatLon && Lf.endLatLon) {
            const sKey = roundKey(Lf.startLatLon.lat, Lf.startLatLon.lon);
            const eKey = roundKey(Lf.endLatLon.lat, Lf.endLatLon.lon);
            const sElev = demCache.get(sKey);
            const eElev = demCache.get(eKey);
            if (typeof sElev === 'number' || typeof eElev === 'number') {
              Lf.topEleFinal = Math.max(
                typeof sElev === 'number' ? sElev : -Infinity,
                typeof eElev === 'number' ? eElev : -Infinity
              );
              if (!Number.isFinite(Lf.topEleFinal)) Lf.topEleFinal = null;
              else Lf.source = 'dem';
            }
          }
        }

        // 4) Render lifts (apply minEle AFTER final topEle decided)
        for (const Lf of liftInfo) {
          const { w, tags, coords, ndStart, ndEnd, topEleFinal, source } = Lf;
          if (coords.length < 2) continue;

          if (minEle > 0 && (topEleFinal == null || topEleFinal < minEle)) continue;

          const color = liftColor(tags);
          const name = tags.name || `Lift: ${tags.aerialway || 'unknown'}`;
          const osmWay = `https://www.openstreetmap.org/way/${w.id}`;

          const topLine = (topEleFinal != null)
            ? `<div><b>Top ele</b>: ${Math.round(topEleFinal)} m${source === 'dem' ? ' <i>(DEM)</i>' : ''}</div>`
            : '';

          const wayPopup = `
            <div style="min-width:260px">
              <div style="font-weight:600">${name}</div>
              <div>Aerialway: <b>${tags.aerialway || 'unknown'}</b></div>
              ${topLine}
              <hr>
              ${htmlTags(tags)}
              <hr>
              <a href="${osmWay}" target="_blank" rel="noopener noreferrer">View lift on OSM</a>
            </div>
          `;

          // Draw polyline
          L.polyline(coords, { color, weight: 3, opacity: 0.9 })
            .addTo(lineLayer)
            .bindPopup(wayPopup);

          // Midpoint marker (for easy clicking)
          const mid = coords[Math.floor(coords.length / 2)];
          L.circleMarker(mid, { radius: 5, color, weight: 2, fillOpacity: 0.7 })
            .addTo(markerLayer)
            .bindPopup(wayPopup);

          // Endpoint nodes (show tag ele OR DEM if tags missing & DEM used)
          const endpoints = [
            { nd: ndStart, fallbackLatLon: Lf.startLatLon, label: 'Lift start' },
            { nd: ndEnd,   fallbackLatLon: Lf.endLatLon,   label: 'Lift end' }
          ];

          endpoints.forEach(({ nd, fallbackLatLon, label }) => {
            let latlng = null;
            let eleVal = parseEle(nd?.tags?.ele);
            let eleFromDem = false;

            if (nd) {
              latlng = [nd.lat, nd.lon];
            } else if (fallbackLatLon) {
              latlng = [fallbackLatLon.lat, fallbackLatLon.lon];
            }

            if (latlng) {
              if (eleVal == null && demFallback.checked && fallbackLatLon) {
                const k = roundKey(fallbackLatLon.lat, fallbackLatLon.lon);
                const dem = demCache.get(k);
                if (typeof dem === 'number') { eleVal = dem; eleFromDem = true; }
              }

              // Respect minEle filter for endpoints only if an elevation is known
              if (getMinEleMeters() > 0 && eleVal != null && eleVal < getMinEleMeters()) return;

              const nameNode = nd?.tags?.name || (nd?.tags?.aerialway ? `Node: ${nd.tags.aerialway}` : label);
              const eleHtml = eleVal != null
                ? `<div><b>Elevation</b>: ${Math.round(eleVal)} m${eleFromDem ? ' <i>(DEM)</i>' : ''}</div>`
                : '';

              const osmNode = nd ? `https://www.openstreetmap.org/node/${nd.id}` : null;
              const tagsHtml = nd ? htmlTags(nd.tags || {}) : '<i>No additional details</i>';
              const osmLink = osmNode ? `<hr><a href="${osmNode}" target="_blank" rel="noopener noreferrer">View node on OSM</a>` : '';

              const nodePopup = `
                <div style="min-width:240px">
                  <div style="font-weight:600">${nameNode}</div>
                  ${eleHtml}
                  <hr>
                  ${tagsHtml}
                  ${osmLink}
                </div>
              `;

              L.circleMarker(latlng, { radius: 5, color, weight: 2, fillOpacity: 0.7 })
                .addTo(markerLayer)
                .bindPopup(nodePopup);
            }
          });
        }

        // 5) Standalone station nodes (optional, honors ele filter; no DEM for stations)
        if (stationsInput.checked) {
          for (const el of data.elements) {
            if (el.type === 'node' && el.tags && el.tags.aerialway === 'station') {
              const ele = parseEle(el.tags.ele);
              if (getMinEleMeters() > 0) {
                if (ele == null || ele < getMinEleMeters()) continue;
              }
              const tags = el.tags;
              const name = tags.name || 'Ski station';
              const osm = `https://www.openstreetmap.org/node/${el.id}`;
              const popup = `
                <div style="min-width:240px">
                  <div style="font-weight:600">${name}</div>
                  <div>Type: <b>${tags.aerialway}</b></div>
                  ${ele != null ? `<div><b>Elevation</b>: ${Math.round(ele)} m</div>` : ``}
                  <hr>
                  ${htmlTags(tags)}
                  <hr>
                  <a href="${osm}" target="_blank" rel="noopener noreferrer">View station on OSM</a>
                </div>
              `;
              L.circleMarker([el.lat, el.lon], {
                radius: 6, color: '#ff7f0e', weight: 2, fillOpacity: 0.75
              }).addTo(markerLayer).bindPopup(popup);
            }
          }
        }

        // Fit to results
        const bounds = L.latLngBounds([]);
        lineLayer.eachLayer(l => { try { bounds.extend(l.getBounds()); } catch {} });
        markerLayer.eachLayer(l => { try { bounds.extend(l.getLatLng()); } catch {} });
        if (bounds.isValid()) map.fitBounds(bounds.pad(0.12));

      } catch (err) {
        console.error('Overpass error:', err);
        alert('Fetching lifts failed. Please try again (the Overpass servers might be busy).');
      } finally {
        showLoading(false);
      }
    }

    // --- Map click handler
    map.on('click', (e) => {
      lastClickLatLng = e.latlng;
      updateRadiusNote();
      updateEleNote();
      writeStateToURL();
      findLiftsNear(lastClickLatLng.lat, lastClickLatLng.lng, getRadiusMeters());
    });

    // --- React to control/view changes
    function refreshIfReady() {
      updateRadiusNote();
      updateEleNote();
      writeStateToURL();
      if (lastClickLatLng) {
        findLiftsNear(lastClickLatLng.lat, lastClickLatLng.lng, getRadiusMeters());
      } else if (circleLayer) {
        circleLayer.setRadius(getRadiusMeters());
      }
    }
    radiusInput.addEventListener('input', refreshIfReady);
    radiusInput.addEventListener('change', refreshIfReady);
    minEleInput.addEventListener('input', refreshIfReady);
    minEleInput.addEventListener('change', refreshIfReady);
    stationsInput.addEventListener('change', refreshIfReady);
    demFallback.addEventListener('change', refreshIfReady);

    // Init labels
    updateRadiusNote();
    updateEleNote();

    // Restore from permalink (if present) and optionally auto-query
    (function initFromURL(){
      const st = readStateFromURL();
      if (st.radiusKm) radiusInput.value = st.radiusKm;
      if (typeof st.minEle === 'number' && !Number.isNaN(st.minEle)) minEleInput.value = st.minEle;
      if (typeof st.stations === 'boolean') stationsInput.checked = st.stations;
      if (typeof st.dem === 'boolean') demFallback.checked = st.dem;
      updateRadiusNote();
      updateEleNote();

      if (st.center) {
        map.setView(st.center, st.zoom || initialZoom);
      } else {
        map.setView([initialLat, initialLon], initialZoom);
      }

      if (st.center && st.autoQuery) {
        lastClickLatLng = L.latLng(st.center[0], st.center[1]);
        findLiftsNear(lastClickLatLng.lat, lastClickLatLng.lng, getRadiusMeters());
      }
    })();
  </script>
</body>
</html>
